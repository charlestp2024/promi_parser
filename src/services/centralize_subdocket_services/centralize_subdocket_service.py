from sqlalchemy.orm import Session
from datetime import datetime
from decimal import Decimal
import uuid

from models.pmv_csd_models import (
    Subdocket,
    SubdocketUserRolesMapping,
    SubdocketAssigneeMapping,
    ForeignFilingCountry,
    FilingType,
    SubdocketLogs,
    Countries,
    Assignee,
    User,
)
from services.utils.subdocket_dto import SubdocketDTO
from services.utils.subdocket_static_cache import (
    subdocket_status_id_by_name,
    subdocket_filing_entity_id_by_name,
)
from models.invention_disclosure_models import Docket
from services.utils.role_constants import RoleEnum
from services.utils.subdocket_static_cache import (
    subdocket_filing_type_code_by_name,
    subdocket_filing_type_id_by_name,
)
from services.utils.lookup_cache import (
    uuid_for_user_name,
    uuid_for_department,
    client_entry,
)
from services.utils.parser_utils import parse_date, parse_decimal
from services.utils.static_cache import country_id_by_name_or_code
from excel.ExcelData import ExcelColumns
from services.logger import logger


SUBDOCKET_ROLE_COLUMN_MAPPING = {
    ExcelColumns.ANALYST: RoleEnum.ANALYST,
    ExcelColumns.PATENT_AGENT: RoleEnum.PATENT_AGENT,
    ExcelColumns.INVENTORS: RoleEnum.INVENTOR,
}


def process_subdocket_roles(session: Session, row: dict, subdocket_: Subdocket):
    for column, role_enum in SUBDOCKET_ROLE_COLUMN_MAPPING.items():
        user_names = row.get(column, "")
        if not user_names:
            continue
        for user_name in user_names.split(","):
            user_name = user_name.strip()
            if not user_name:
                continue
            user_uuid = uuid_for_user_name(user_name)
            if not user_uuid:
                logger.warning(
                    f"User '{user_name}' not found in cache, skipping role assignment for role '{role_enum.label}'"
                )
                continue
            session.add(
                SubdocketUserRolesMapping(
                    subdocket=subdocket_,
                    user_id=user_uuid,
                    role_id=role_enum.id,
                    created_on=datetime.utcnow(),
                    modified_on=datetime.utcnow(),
                )
            )
            logger.info(
                f"✓ Role '{role_enum.label}' assigned to '{user_name}' for subdocket ID {subdocket_.id}"
            )


def get_max_temp_number(session: Session) -> int:
    result = (
        session.query(Subdocket.temp_number)
        .order_by(Subdocket.temp_number.desc())
        .first()
    )
    return (result[0] + 1) if result and result[0] != 0 else 1


def get_autogenerated_subdocket_number(
    session: Session, row: dict, docket_number: str
) -> str:
    temp_number = get_max_temp_number(session)

    filing_type_name = row.get(ExcelColumns.TYPE_OF_FILING)
    if not filing_type_name:
        logger.info(f"Missing 'Type Of Filing' in row: {row}")
        raise ValueError("Missing 'Type Of Filing' – cannot generate subdocket number.")

    try:
        filing_type_code = subdocket_filing_type_code_by_name(filing_type_name)
    except ValueError as e:
        logger.error(str(e))
        raise

    country_name = row.get(ExcelColumns.COUNTRY_OF_FILING)
    if not country_name:
        raise ValueError(
            "Missing 'Country Of Filing' – cannot generate subdocket number."
        )

    try:
        country_code = country_id_by_name_or_code(country_name)
    except ValueError as e:
        logger.error(str(e))
        raise

    padded_temp = str(temp_number).zfill(4)
    return f"{docket_number}/{country_code}/{filing_type_code}/{padded_temp}"


def handle_foreign_filing_countries(
    session: Session, row: dict, subdocket_: Subdocket, user_id: str
):
    countries_raw = row.get(ExcelColumns.SUBDOCKET_FOREIGN_FILING_COUNTRIES, "")
    if not countries_raw:
        return
    for name in countries_raw.split(","):
        country_name = name.strip()
        if not country_name:
            continue
        try:
            country_id = country_id_by_name_or_code(country_name)
        except Exception as e:
            logger.warning(f"Invalid foreign filing country '{country_name}': {e}")
            continue
        session.add(
            ForeignFilingCountry(
                subdocket=subdocket_,
                country_id=country_id,
                added_by=user_id,
                created_on=datetime.utcnow(),
                modified_on=datetime.utcnow(),
            )
        )
        logger.info(
            f"✓ Foreign country '{country_name}' linked to subdocket ID {subdocket_.id}"
        )


def handle_assignees(
    session: Session,
    assignee_names: list[str],
    subdocket: Subdocket,
    user: str,
    tenant_id: str,
    client_uuid: str,
) -> list[SubdocketAssigneeMapping]:
    mappings = []
    for name in assignee_names:
        name = name.strip()
        if not name:
            continue

        assignee = (
            session.query(Assignee).filter_by(name=name, tenant_id=tenant_id).first()
        )

        if not assignee:
            assignee = Assignee(
                name=name,
                client_id=client_uuid,
                tenant_id=tenant_id,
                added_by=user,
                created_on=datetime.utcnow(),
                modified_on=datetime.utcnow(),
            )
            session.add(assignee)
            session.flush()

        mapping = SubdocketAssigneeMapping(
            subdocket_id=subdocket.id,
            assignee=assignee,
            added_by=user,
            created_on=datetime.utcnow(),
            modified_on=datetime.utcnow(),
        )
        session.add(mapping)
        mappings.append(mapping)

    return mappings


def save_subdocket(
    session: Session,
    ict_session,
    row: dict,
    docket_number: str,
    tenant_id: str,
    import_user_id: str,
):
    # --- 1. Mandatory Lookups ---
    # Find the parent docket; skip this subdocket if not found.
    docket = (
        ict_session.query(Docket)
        .filter(
            (Docket.manual_docket_number == docket_number)
            | (Docket.system_generated_docket_number == docket_number),
            Docket.tenant_id == tenant_id,
        )
        .first()
    )

    if not docket:
        logger.warning(
            f"✗ Skipping subdocket save – docket '{docket_number}' not found in Invention Disclosure DB."
        )
        return

    # Client and Department are essential for creating the subdocket.
    client_name = row.get(ExcelColumns.CLIENT)
    if not client_name:
        raise ValueError(f"Client is missing in the row for docket '{docket_number}'.")

    client_info = client_entry(client_name)
    if not client_info:
        raise ValueError(f"Client not found in cache: {client_name}")
    client_uuid = client_info["uuid"]

    dept_name = row.get(ExcelColumns.DEPARTMENT)
    if not dept_name:
        raise ValueError(f"Department is missing for client '{client_name}'.")

    department_uuid = uuid_for_department(client_name, dept_name)
    if not department_uuid:
        raise ValueError(f"Department not found: {dept_name} for client {client_name}")

    # --- 2. Check for Existing Subdocket (NEW) ---
    # Only check for duplicates if a manual subdocket number is provided in the row.
    manual_subdocket_number = row.get(ExcelColumns.SUB_DOCKET_NUMBER)
    if manual_subdocket_number:
        existing_subdocket = (
            session.query(Subdocket)
            .filter_by(
                docket_number=docket_number,
                manual_subdocket_number=manual_subdocket_number,
                tenant_id=tenant_id,
            )
            .first()
        )
        if existing_subdocket:
            logger.info(
                f"✓ Found existing subdocket '{manual_subdocket_number}'. "
                f"Converting to DTO and passing to downstream services."
            )

            return convert_subdocket_to_dto(existing_subdocket)

    subdocket = Subdocket(
        uuid=uuid.uuid4(),
        docket_uuid=docket.uuid,
        docket_number=docket_number,
        appid="80247b94-efdf-11ed-8f46-5a43ae00effd",
        tenant_id=tenant_id,
        added_by=import_user_id,
        created_on=datetime.utcnow(),
        modified_on=datetime.utcnow(),
        archived=False,
        client_id=client_uuid,
        department_id=department_uuid,
        # Generate system number and set temp number (required fields).
        system_generated_subdocket_number=get_autogenerated_subdocket_number(
            session, row, docket.system_generated_docket_number
        ),
        temp_number=get_max_temp_number(session),
        # Country of Filing is required for the system-generated number.
        country_of_filing_id=country_id_by_name_or_code(
            row.get(ExcelColumns.COUNTRY_OF_FILING)
        ),
    )

    # --- 3. Conditionally Set Optional Fields ---
    # The following fields will only be set if a non-empty value is provided in the Excel row.

    # Basic Info
    if manual_number := row.get(ExcelColumns.SUB_DOCKET_NUMBER):
        subdocket.manual_subdocket_number = manual_number
    if app_number := row.get(ExcelColumns.APPLICATION_NUMBER):
        subdocket.application_number = app_number
    if pub_number := row.get(ExcelColumns.PUBLICATION_NUMBER):
        subdocket.publication_number = pub_number

    # Dates
    if date_str := row.get(ExcelColumns.TENTATIVE_FILING_DATE):
        subdocket.tentative_filing_date = parse_date(date_str)
    if date_str := row.get(ExcelColumns.PRIOR_FILING_DATE):
        subdocket.prior_filing_date = parse_date(date_str)
    if date_str := row.get(ExcelColumns.PRIORITY_DATE):
        subdocket.priority_date = parse_date(date_str)
    if date_str := row.get(ExcelColumns.FILING_DATE):
        subdocket.filing_date = parse_date(date_str)
    if date_str := row.get(ExcelColumns.PUBLICATION_DATE):
        subdocket.publication_date = parse_date(date_str)
    if date_str := row.get(ExcelColumns.GRANT_DATE):
        subdocket.grant_date = parse_date(date_str)
    if year_val := row.get(ExcelColumns.EXPECTED_FILING_YEAR):
        subdocket.expected_filing_year = parse_date(str(year_val))
    if date_str := row.get(ExcelColumns.RECENT_OA_RECEIVED_DATE):
        subdocket.recent_action_recieved_date = parse_date(date_str)
    if date_str := row.get(ExcelColumns.TERM_EXTENSION):
        subdocket.term_extention = parse_date(date_str)

    # Optional Lookups & Values
    if office_country := row.get(ExcelColumns.PATENT_OFFICE_COUNTRY):
        try:
            subdocket.patent_office_id = country_id_by_name_or_code(office_country)
        except Exception as e:
            logger.warning(
                f"Invalid Patent Office Country '{office_country}': {e}. Skipping field."
            )

    if cost_val := row.get(ExcelColumns.SUBDOCKET_FILING_MAINTENANCE_COST_ESTIMATE):
        try:
            subdocket.filing_maintenance_cost_estimate = Decimal(cost_val)
        except Exception:
            logger.warning(f"Invalid maintenance cost '{cost_val}'. Skipping field.")

    # Status, Filing Entity, and Type of Filing are critical if present.
    if status_name := row.get(ExcelColumns.STATUS):
        try:
            subdocket.status_id = subdocket_status_id_by_name(status_name)
        except Exception as e:
            logger.error(f"Invalid status '{status_name}': {e}")
            raise
    if entity_name := row.get(ExcelColumns.TYPE_OF_FILING_ENTITY):
        try:
            subdocket.filing_entity_type_id = subdocket_filing_entity_id_by_name(
                entity_name
            )
        except Exception as e:
            logger.error(f"Invalid Filing Entity Type '{entity_name}': {e}")
            raise
    if filing_type_name := row.get(ExcelColumns.TYPE_OF_FILING):
        try:
            subdocket.type_of_filing_id = subdocket_filing_type_id_by_name(
                filing_type_name
            )
        except Exception as e:
            logger.error(f"Invalid Type of Filing '{filing_type_name}': {e}")
            raise

    # --- 4. Add to Session and Flush to Get ID ---
    session.add(subdocket)
    session.flush()  # Flush to assign subdocket.id for use in related objects

    # --- 5. Handle Related Objects ---
    # These functions have internal checks for empty values.
    handle_foreign_filing_countries(session, row, subdocket, import_user_id)

    # Handle Assignees, supporting comma-separated values
    if assignee_str := row.get(ExcelColumns.ASSIGNEE_NAME):
        assignee_names = [
            name.strip() for name in assignee_str.split(",") if name.strip()
        ]
        if assignee_names:
            handle_assignees(
                session,
                assignee_names,
                subdocket,
                import_user_id,
                tenant_id,
                client_uuid,
            )

    # Handle User Role Mappings
    process_subdocket_roles(session, row, subdocket)
    
    # --- 6. Finalize with a Log Entry ---
    log = SubdocketLogs(
        subdocket_id=subdocket.id,
        client_id=subdocket.client_id,
        tenant_id=subdocket.tenant_id,
        added_by=import_user_id,
        created_on=datetime.utcnow(),
        modified_on=datetime.utcnow(),
        logs="Subdocket created successfully via bulk import.",
    )
    session.add(log)
    logger.info(
        f"✓ Subdocket saved: {subdocket.manual_subdocket_number or subdocket.system_generated_subdocket_number} for docket: {docket_number}"
    )
   


    # ---  Convert to DTO and Return (NEW) ---
    subdocket_dto = convert_subdocket_to_dto(subdocket)

    return subdocket_dto


def convert_subdocket_to_dto(subdocket: Subdocket) -> SubdocketDTO:
    """
    Converts a saved Subdocket SQLAlchemy model to a SubdocketDTO.

    This function should be called after the session has been flushed so that
    the subdocket object has its ID and relationships populated.
    """
    # 1. Process user roles using role IDs for consistency and robustness.
    
    # Create a map of {role_id: user_id} for single-user roles.
    # We now use `ur.role_id` as the key, which is more reliable than a string label.
    role_map = {
        ur.role_id: ur.user_id for ur in subdocket.subdocket_user_role_mappings
    }

    # Collect all user_ids for the Inventor role by comparing IDs.
    inventor_ids = [
        ur.user_id
        for ur in subdocket.subdocket_user_role_mappings
        if ur.role_id == RoleEnum.INVENTOR.id
    ]

    foreign_country_ids = [
        mapping.country_id
        for mapping in subdocket.subdocket_foreign_filing_country_mappings
    ]

    # 3. Create and return the DTO
    return SubdocketDTO(
        id=subdocket.id,
        uuid=str(subdocket.uuid),
        docket_uuid=str(subdocket.docket_uuid),
        tenant_id=subdocket.tenant_id,
        client_id=str(subdocket.client_id),
        department_id=str(subdocket.department_id),
        system_generated_subdocket_number=subdocket.system_generated_subdocket_number,
        manual_subdocket_number=subdocket.manual_subdocket_number,
        docket_number=subdocket.docket_number,
        application_number=subdocket.application_number,
        publication_number=subdocket.publication_number,
        status_id=subdocket.status_id,
        filing_entity_type_id=subdocket.filing_entity_type_id,
        type_of_filing_id=subdocket.type_of_filing_id,
        country_of_filing_id=subdocket.country_of_filing_id,
        patent_office_id=subdocket.patent_office_id,
        filing_maintenance_cost_estimate=subdocket.filing_maintenance_cost_estimate,
        
        # Dates
        filing_date=subdocket.filing_date,
        publication_date=subdocket.publication_date,
        grant_date=subdocket.grant_date,
        priority_date=subdocket.priority_date,
        prior_filing_date=subdocket.prior_filing_date,
        tentative_filing_date=subdocket.tentative_filing_date,
        expected_filing_year=subdocket.expected_filing_year,
        recent_action_recieved_date=subdocket.recent_action_recieved_date,
        term_extention=subdocket.term_extention,
        
        # Related IDs
        
        patent_agent_id=role_map.get(RoleEnum.PATENT_AGENT.id),
        inventor_ids=inventor_ids,
        foreign_filing_countries_ids=foreign_country_ids,
        analyst_id=role_map.get(RoleEnum.ANALYST.id),
        # Timestamps
        created_on=subdocket.created_on,
        modified_on=subdocket.modified_on,
        added_by=subdocket.added_by,
    )