from sqlalchemy.orm import Session
from datetime import datetime
from decimal import Decimal
import uuid

from models.pmv_csd_models import (
    Subdocket,
    SubdocketUserRolesMapping,
    SubdocketAssigneeMapping,
    ForeignFilingCountry,
    FilingType,
    SubdocketLogs,
    Countries,
    Assignee,
    User,
)
from models.invention_disclosure_models import Docket
from services.utils.role_constants import RoleEnum
from services.utils.subdocket_static_cache import subdocket_filing_type_code_by_name
from services.utils.lookup_cache import (
    uuid_for_user_name,
    uuid_for_department,
    client_entry,
)
from services.utils.static_cache import country_code_by_name
from excel.ExcelData import ExcelColumns
from services.logger import logger


SUBDOCKET_ROLE_COLUMN_MAPPING = {
    ExcelColumns.ANALYST: RoleEnum.ANALYST,
    ExcelColumns.PATENT_AGENT: RoleEnum.PATENT_AGENT,
    ExcelColumns.INVENTORS: RoleEnum.INVENTOR,
}


def process_subdocket_roles(session: Session, row: dict, subdocket_id: int):
    for column, role_enum in SUBDOCKET_ROLE_COLUMN_MAPPING.items():
        user_names = row.get(column, "")
        if not user_names:
            continue
        for user_name in user_names.split(","):
            user_name = user_name.strip()
            if not user_name:
                continue
            user_uuid = uuid_for_user_name(user_name)
            if not user_uuid:
                logger.warning(
                    f"User '{user_name}' not found in cache, skipping role assignment for role '{role_enum.label}'"
                )
                continue
            session.add(
                SubdocketUserRolesMapping(
                    subdocket_id=subdocket_id,
                    user_id=user_uuid,
                    role_id=role_enum.id,
                    created_on=datetime.utcnow(),
                    modified_on=datetime.utcnow(),
                )
            )
            logger.info(
                f"✓ Role '{role_enum.label}' assigned to '{user_name}' for subdocket ID {subdocket_id}"
            )


def get_max_temp_number(session: Session) -> int:
    result = (
        session.query(Subdocket.temp_number)
        .order_by(Subdocket.temp_number.desc())
        .first()
    )
    return (result[0] + 1) if result and result[0] != 0 else 1


def get_autogenerated_subdocket_number(
    session: Session, row: dict, docket_number: str
) -> str:
    temp_number = get_max_temp_number(session)

    filing_type_name = row.get(ExcelColumns.TYPE_OF_FILING)
    if not filing_type_name:
        logger.error(f"Missing 'Type Of Filing' in row: {row}")
        raise ValueError("Missing 'Type Of Filing' – cannot generate subdocket number.")

    try:
        filing_type_code = subdocket_filing_type_code_by_name(filing_type_name)
    except ValueError as e:
        logger.error(str(e))
        raise

    country_name = row.get(ExcelColumns.COUNTRY_OF_FILING)
    if not country_name:
        raise ValueError("Missing 'Country Of Filing' – cannot generate subdocket number.")

    try:
        country_code = country_code_by_name(country_name)
    except ValueError as e:
        logger.error(str(e))
        raise

    padded_temp = str(temp_number).zfill(4)
    return f"{docket_number}/{country_code}/{filing_type_code}/{padded_temp}"


def handle_assignees(
    session: Session,
    assignee_names: list[str],
    subdocket: Subdocket,
    user: str,
    tenant_id: str,
    client_uuid: str,
) -> list[SubdocketAssigneeMapping]:
    mappings = []
    for name in assignee_names:
        name = name.strip()
        if not name:
            continue

        assignee = (
            session.query(Assignee)
            .filter_by(name=name, tenant_id=tenant_id)
            .first()
        )

        if not assignee:
            assignee = Assignee(
                name=name,
                client_id=client_uuid,
                tenant_id=tenant_id,
                added_by=user,
                created_on=datetime.utcnow(),
                modified_on=datetime.utcnow(),
            )
            session.add(assignee)
            session.flush()

        mapping = SubdocketAssigneeMapping(
            subdocket_id=subdocket.id,
            assignee=assignee,
            added_by=user,
            created_on=datetime.utcnow(),
            modified_on=datetime.utcnow(),
        )
        session.add(mapping)
        mappings.append(mapping)

    return mappings


def save_subdocket(
    session: Session,
    ict_session,
    row: dict,
    docket_number: str,
    tenant_id: str,
    import_user_id: str,
):
    docket = (
        ict_session.query(Docket)
        .filter(
            (Docket.manual_docket_number == docket_number)
            | (Docket.system_generated_docket_number == docket_number),
            Docket.tenant_id == tenant_id,
        )
        .first()
    )

    if not docket:
        logger.warning(
            f"✗ Skipping subdocket save – docket '{docket_number}' not found in Invention Disclosure DB."
        )
        return

    docket_uuid = docket.uuid
    client_name = row[ExcelColumns.CLIENT]
    dept_name = row[ExcelColumns.DEPARTMENT]
    div_name = row[ExcelColumns.CLIENT_DIVISION]

    client_info = client_entry(client_name)
    if not client_info:
        raise ValueError(f"Client not found in cache: {client_name}")

    client_uuid = client_info["uuid"]
    department_uuid = uuid_for_department(client_name, dept_name)

    if not department_uuid:
        raise ValueError(f"Department not found: {dept_name} for client {client_name}")

    subdocket = Subdocket(
        uuid=uuid.uuid4(),
        docket_uuid=docket_uuid,
        docket_number=docket_number,
        appid="80247b94-efdf-11ed-8f46-5a43ae00effd",
        tenant_id=tenant_id,
        added_by=import_user_id,
        created_on=datetime.utcnow(),
        modified_on=datetime.utcnow(),
        archived=False,
    )

    subdocket.client_id = client_uuid
    subdocket.department_id = department_uuid

    subdocket.manual_subdocket_number = row.get(ExcelColumns.SUB_DOCKET_NUMBER)
    subdocket.system_generated_subdocket_number = get_autogenerated_subdocket_number(
        session, row, docket.system_generated_docket_number
    )
    subdocket.temp_number = get_max_temp_number(session)
    subdocket.application_number = row.get(ExcelColumns.APPLICATION_NUMBER)
    subdocket.publication_number = row.get(ExcelColumns.PUBLICATION_NUMBER)

    def parse_date(raw_value):
        if not raw_value:
            return None
        value = str(raw_value).strip()
        if " " in value:
            value = value.split(" ")[0]
        try:
            return datetime.strptime(value, "%Y-%m-%d")
        except ValueError as e:
            logger.warning(f"Invalid date format: {value} — {e}")
            return None

    subdocket.tentative_filing_date = parse_date(row.get(ExcelColumns.TENTATIVE_FILING_DATE))
    subdocket.prior_filing_date = parse_date(row.get(ExcelColumns.PRIOR_FILING_DATE))
    subdocket.priority_date = parse_date(row.get(ExcelColumns.PRIORITY_DATE))
    subdocket.filing_date = parse_date(row.get(ExcelColumns.FILING_DATE))
    subdocket.publication_date = parse_date(row.get(ExcelColumns.PUBLICATION_DATE))
    subdocket.grant_date = parse_date(row.get(ExcelColumns.GRANT_DATE))
    subdocket.expected_filing_year = parse_date(str(row.get(ExcelColumns.EXPECTED_FILING_YEAR))) if row.get(ExcelColumns.EXPECTED_FILING_YEAR) else None
    subdocket.recent_action_recieved_date = parse_date(row.get(ExcelColumns.RECENT_OA_RECEIVED_DATE))
    subdocket.term_extention = parse_date(row.get(ExcelColumns.TERM_EXTENSION))

    if cost := row.get(ExcelColumns.FILING_MAINTENANCE_COST_ESTIMATE_SUB):
        try:
            subdocket.filing_maintenance_cost_estimate = Decimal(cost)
        except Exception:
            logger.warning(f"Invalid maintenance cost: {cost}")

    session.add(subdocket)
    session.flush()

    # Assignees
    assignee_names = [row.get(ExcelColumns.ASSIGNEE_NAME, "")]
    handle_assignees(session, assignee_names, subdocket, import_user_id, tenant_id, client_uuid)

    
    # User Role Mapping
    process_subdocket_roles(session, row, subdocket.id)

    # Logs
    log = SubdocketLogs(
        subdocket_id=subdocket.id,
        client_id=subdocket.client_id,
        tenant_id=subdocket.tenant_id,
        added_by=import_user_id,
        created_on=datetime.utcnow(),
        modified_on=datetime.utcnow(),
        logs="Subdocket Created",
    )
    session.add(log)

    logger.info(
        f"✓ Subdocket saved: {subdocket.manual_subdocket_number} for docket: {docket_number}"
    )
